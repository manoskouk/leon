object SortedListSimpleExpanded {
  def test(l : List, i : Int) : List = {
    insert(l, i)
  }

  def psr(input : Int) : Int = {
    (input * 476272 + 938709) % 187987
  }

  def insert(l : List, v : Int) : List = {
    require(isSorted(l));
    l match {
      case Nil(_) =>
        createCons(v, createNil())
      case Cons(x, tail, _) =>
        if (v < x) {
          createCons(v, l)
        } else {
          if (v == x) {
            l
          } else {
            createCons(x, insert(tail, v))
          }
        }
    }
  } ensuring { x$1 => isSorted(x$1) }

  def init() : Nil = {
    createNil()
  } ensuring { res => res.isInstanceOf[Nil] }

  sealed abstract class List

  sealed abstract class ListFieldsAbstract

  case class ListFields(isSorted: Boolean) extends ListFieldsAbstract

  case class Nil(listFields: ListFields) extends List

  case class Cons(head: Int, tail: List, listFields: ListFields) extends List

  def listFields(list : List) : ListFields = {
    list match {
      case nil @ Nil(_) =>
        nil.listFields
      case cons @ Cons(_, _, _) =>
        cons.listFields
    }
  }

  def isSorted(l : List) : Boolean = {
    listFields(l).isSorted
  }

  def createNil() : Nil = {
    val isSorted_ = true
    Nil(ListFields(isSorted_))

  }

  def createCons(head : Int, tail : List) : Cons = {
    val isSorted_ = (head, tail) match {
      case (x, Nil(_)) =>
        true
      case (x, xs @ Cons(y, _, _)) =>
        x <= y && isSorted(xs)
    }
    Cons(head, tail, ListFields(isSorted_))

  } 
   def main(args : Array[String]) = { 
    val t1 = System.nanoTime
    var t : List = init()
    var i : Int = args(0).toInt
    while (i > 0) {
      t = test(t,psr(i))
      i = i - 1
    }
    val t2 = System.nanoTime
    println( (t2-t1)/1000)
  }
 
                                      
}
